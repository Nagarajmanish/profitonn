

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binance Real-Time Data on TradingView Chart</title>
    <script src="./charting_library/charting_library.standalone.js"></script>
    <style>
        #chart-container {
            width: 100%;
            height: 600px;
        }
    </style>
</head>
<body>

<div id="chart-container"></div>

<script>
    class Datafeed {
        constructor() {
            this.aggregatedBar = null;
            this.aggregationInterval = 1000; // 1 second in milliseconds
            this.intervalStart = null;
        }

        onReady(callback) {
            setTimeout(() => callback({
                exchanges: [{ value: "BINANCE", name: "Binance", desc: "Binance Exchange" }],
                symbolsTypes: [{ name: "crypto", value: "crypto" }],
                supported_resolutions: ["1", "5", "15", "30", "60", "240", "1D"]
            }), 0);
        }

        resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
            const symbolStub = {
                name: symbolName,
                ticker: symbolName,
                type: 'crypto',
                session: '24x7',
                timezone: 'Etc/UTC',
                exchange: 'Binance',
                minmov: 1,
                pricescale: 100,
                has_intraday: true,
                intraday_multipliers: ['1', '5', '15', '30', '60'],
                supported_resolutions: ["1", "5", "15", "30", "60", "240", "1D"],
                volume_precision: 8,
                data_status: 'streaming'
            };
            setTimeout(() => onSymbolResolvedCallback(symbolStub), 0);
        }

        getBars(symbolInfo, resolution, { from, to }, onHistoryCallback, onErrorCallback, firstDataRequest) {
            const binanceSymbol = symbolInfo.ticker.replace("BINANCE:", "");
            const interval = this.convertResolution(resolution);

            const BinanceUrl = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${interval}&startTime=${from * 1000}&endTime=${to * 1000}`;
            fetch(`http://localhost:3000/proxy?url=${encodeURIComponent(BinanceUrl)}`)
                .then(response => response.json())
                .then(data => {
                    const bars = data.map(el => ({
                        time: el[0],
                        low: parseFloat(el[3]),
                        high: parseFloat(el[2]),
                        open: parseFloat(el[1]),
                        close: parseFloat(el[4]),
                        volume: parseFloat(el[5]),
                    }));
                    onHistoryCallback(bars, { noData: bars.length === 0 });
                })
                .catch(err => onErrorCallback(err));
        }

        subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) {
            const binanceSymbol = symbolInfo.ticker.replace("BINANCE:", "").toLowerCase();

            // Set up WebSocket connection
            this.binanceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/${binanceSymbol}@trade`);

            this.binanceSocket.onmessage = event => {
                const data = JSON.parse(event.data);
                console.log(data)

                // Handle aggregation logic
                const currentPrice = parseFloat(data.p);
                const currentTime = Math.floor(data.T / this.aggregationInterval) * this.aggregationInterval;

                // Initialize a new bar if no aggregation has started or the interval is complete
                if (!this.aggregatedBar || currentTime !== this.intervalStart) {
                    if (this.aggregatedBar) {
                        onRealtimeCallback(this.aggregatedBar); // Send completed bar
                    }
                    // Start a new bar
                    this.intervalStart = currentTime;
                    this.aggregatedBar = {
                        time: currentTime,
                        open: currentPrice,
                        high: currentPrice,
                        low: currentPrice,
                        close: currentPrice,
                        volume: 0
                    };
                } else {
                    // Update the existing bar's high, low, close, and volume
                    this.aggregatedBar.close = currentPrice;
                    this.aggregatedBar.high = Math.max(this.aggregatedBar.high, currentPrice);
                    this.aggregatedBar.low = Math.min(this.aggregatedBar.low, currentPrice);
                    this.aggregatedBar.volume += parseFloat(data.q); // Aggregate volume
                }
            };

            this.binanceSocket.onerror = error => {
                console.error("WebSocket error:", error);
            };

            this.binanceSocket.onclose = () => {
                console.log("WebSocket connection closed. Attempting to reconnect...");
                setTimeout(() => this.subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback), 1000); // Reconnect if closed
            };
        }

        unsubscribeBars(subscriberUID) {
            if (this.binanceSocket) {
                this.binanceSocket.close();
            }
        }

        convertResolution(resolution) {
            switch (resolution) {
                case '1': return '1m';
                case '5': return '5m';
                case '15': return '15m';
                case '30': return '30m';
                case '60': return '1h';
                case '240': return '4h';
                case '1D': return '1d';
                default: return '1m';
            }
        }
    }

    const widget = new TradingView.widget({
        symbol: 'BINANCE:BTCUSDT',
        interval: '1',
        container: document.getElementById('chart-container'),
        datafeed: new Datafeed(),
        library_path: './charting_library/',
        locale: 'en',
        timezone: "Asia/Kolkata",
        disabled_features: ["use_localstorage_for_settings"],
        enabled_features: ["study_templates"],
        theme: "Dark",
    });
</script>


</body>
</html>







////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binance Real-Time Data on TradingView Chart</title>
    <script src="./charting_library/charting_library.standalone.js"></script>
    <style>
        #chart-container {
            width: 100%;
            height: 600px;
        }
    </style>
</head>
<body>

<div id="chart-container"></div>

<script>
    async function getAllSymbols() {
        try {
            const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
            const data = await response.json();
            return data.symbols.map(symbol => ({
                symbol: symbol.symbol, // e.g., "BTCUSDT"
                exchange: 'BINANCE',
                description: symbol.baseAsset + ' to ' + symbol.quoteAsset,
                type: 'crypto'
            }));
        } catch (error) {
            console.error('Error fetching symbols:', error);
            return []; // Return an empty array in case of an error
        }
    }

    class Datafeed {
        constructor() {
            this.aggregatedBar = null;
            this.aggregationInterval = 1000; // 1 second in milliseconds
            this.intervalStart = null;
            this.symbols = []; // Array to store all symbols
            this.binanceSocket = null; // WebSocket instance
            this.currentSymbol = null; // Store the currently subscribed symbol
            this.fetchSymbols(); // Fetch symbols when instantiated
        }

        async fetchSymbols() {
            this.symbols = await getAllSymbols(); // Ensure this function returns an array of symbols
            console.log(this.symbols); // Debugging line to check symbols
        }

        async onReady(callback) {
            // Ensure symbols are loaded before calling callback
            await this.fetchSymbols(); // Make sure symbols are fetched
            setTimeout(() => callback({
                exchanges: [{ value: "BINANCE", name: "Binance", desc: "Binance Exchange" }],
                symbolsTypes: [{ name: "crypto", value: "crypto" }],
                supported_resolutions: ["1", "5", "15", "30", "60", "240", "1D"]
            }), 0);
        }

        resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
            const normalizedSymbol = symbolName.trim().toUpperCase();
            const symbolItem = this.symbols.find(({ symbol }) => symbol.toUpperCase() === normalizedSymbol.replace("BINANCE:", ""));

            if (!symbolItem) {
                console.error("Cannot resolve symbol:", normalizedSymbol); // More debug information
                onResolveErrorCallback("cannot resolve symbol");
                return;
            }

            const symbolInfo = {
                ticker: symbolItem.symbol,
                name: symbolItem.symbol,
                description: symbolItem.description,
                type: symbolItem.type,
                session: "24x7",
                timezone: "Etc/UTC",
                exchange: symbolItem.exchange,
                minmov: 1,
                pricescale: 1000,
                has_intraday: true,
                has_weekly_and_monthly: true,
                supported_resolutions: ["1", "5", "15", "30", "60", "240", "1D"],
                volume_precision: 2,
                data_status: "streaming",
            };

            setTimeout(() => onSymbolResolvedCallback(symbolInfo), 0);
        }

        searchSymbols(input, exchange, symbolType, onResult, onError) {
            const filteredSymbols = this.symbols.filter(symbol => {
                return symbol.symbol.toLowerCase().includes(input.toLowerCase());
            });

            const result = filteredSymbols.map(symbol => ({
                symbol: symbol.symbol,
                description: symbol.description,
                exchange: symbol.exchange,
                type: symbol.type,
            }));

            setTimeout(() => onResult(result), 0);
        }

        getBars(symbolInfo, resolution, { from, to }, onHistoryCallback, onErrorCallback, firstDataRequest) {
            const binanceSymbol = symbolInfo.ticker.replace("BINANCE:", "");
            const interval = this.convertResolution(resolution);
            
            const BinanceUrl = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${interval}&startTime=${from * 1000}&endTime=${to * 1000}`;
            
            fetch(BinanceUrl)
                .then(response => response.json())
                .then(data => {
                    const bars = data.map(el => ({
                        time: el[0],
                        low: parseFloat(el[3]),
                        high: parseFloat(el[2]),
                        open: parseFloat(el[1]),
                        close: parseFloat(el[4]),
                        volume: parseFloat(el[5]),
                    }));
                    onHistoryCallback(bars, { noData: bars.length === 0 });
                })
                .catch(err => {
                    console.error(err);
                    onErrorCallback(err);
                });
        }

        subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) {
            const binanceSymbol = symbolInfo.ticker.replace("BINANCE:", "").toLowerCase();

            // Check if we're already subscribed to the same symbol
            if (this.currentSymbol === binanceSymbol) {
                return; // Exit if we're already connected to this symbol
            }

            // Close any existing WebSocket connections
            if (this.binanceSocket) {
                this.binanceSocket.close();
            }

            this.currentSymbol = binanceSymbol; // Update the current symbol

            // Set up WebSocket connection for real-time data
            this.binanceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/${binanceSymbol}@trade`);

            this.binanceSocket.onopen = () => {
                console.log("WebSocket connection established for symbol:", binanceSymbol);
            };

            this.binanceSocket.onmessage = event => {
                const data = JSON.parse(event.data);
                console.log("Received data:", data); // Log received data for debugging
                const currentPrice = parseFloat(data.p);
                const currentTime = Math.floor(data.T / 60000) * 60000; // Round down to the nearest minute
                
                // Handle candlestick updates
                if (!this.aggregatedBar || currentTime !== this.aggregatedBar.time) {
                    if (this.aggregatedBar) {
                        onRealtimeCallback(this.aggregatedBar); // Send completed bar
                    }
                    // Start a new candlestick
                    this.aggregatedBar = {
                        time: currentTime,
                        open: currentPrice,
                        high: currentPrice,
                        low: currentPrice,
                        close: currentPrice,
                        volume: 0,
                    };
                } else {
                    // Update the existing candlestick's high, low, and close
                    this.aggregatedBar.close = currentPrice;
                    this.aggregatedBar.high = Math.max(this.aggregatedBar.high, currentPrice);
                    this.aggregatedBar.low = Math.min(this.aggregatedBar.low, currentPrice);
                    this.aggregatedBar.volume += parseFloat(data.q); // Aggregate volume
                }
            };

            this.binanceSocket.onerror = error => {
                console.error("WebSocket error:", error);
            };

            this.binanceSocket.onclose = () => {
                console.log("WebSocket connection closed for symbol:", binanceSymbol);
                console.log("Attempting to reconnect...");
                // Attempt to reconnect after a short delay
                setTimeout(() => {
                    this.subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback);
                }, 1000);
            };
        }

        unsubscribeBars(subscriberUID) {
            if (this.binanceSocket) {
                this.binanceSocket.close();
                this.binanceSocket = null; // Clear the socket instance
            }
        }

        convertResolution(resolution) {
            switch (resolution) {
                case '1': return '1m';
                case '5': return '5m';
                case '15': return '15m';
                case '30': return '30m';
                case '60': return '1h';
                case '240': return '4h';
                case '1D': return '1d';
                default: return '1m';
            }
        }
    }

    const widget = new TradingView.widget({
        symbol: 'BINANCE:BTCUSDT',
        interval: '1',
        container: document.getElementById('chart-container'),
        datafeed: new Datafeed(),
        library_path: './charting_library/',
        locale: 'en',
        timezone: "Asia/Kolkata",
        disabled_features: ["use_localstorage_for_settings"],
        theme: "Dark",
    });
</script>

</body>
</html>




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptocurrency Chart</title>
    <script src="./charting_library/charting_library.standalone.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        #chart-container {
            height: 500px;
            width: 100%;
        }
    </style>
</head>
<body>

<div id="chart-container"></div>

<script>
    // Maintain the active symbol for filtering real-time data
    let activeSymbol = "BTCUSDT"; // Default symbol

    // Open a single WebSocket connection for all trades
    const ws = new WebSocket("wss://stream.binance.com:9443/ws/!ticker@arr");

    // Function to create a data feed for TradingView
    function createDatafeed() {
        return {
            onReady: (callback) => {
                setTimeout(() => {
                    callback({
                        supports_search: true,
                        supports_group_request: false,
                        supports_marks: false,
                        supports_timescale_marks: false
                    });
                }, 0);
            },
            searchSymbols: async (userInput, exchange, symbolType, onResult) => {
                const response = await fetch(`http://localhost:3000/api/v3/exchangeInfo`);
                const data = await response.json();
                const symbols = data.symbols.map(symbol => ({
                    symbol: symbol.symbol,
                    full_name: symbol.symbol,
                    description: symbol.symbol,
                    exchange: "BINANCE",
                    type: "crypto"
                }));
                onResult(symbols);
            },
            resolveSymbol: (symbolName, onSymbolResolvedCallback, onError) => {
                activeSymbol = symbolName; // Update active symbol when resolved
                setTimeout(() => {
                    onSymbolResolvedCallback({
                        name: symbolName,
                        ticker: symbolName,
                        minmov: 1,
                        pointvalue: 1,
                        session: "24x7",
                        timezone: "UTC",
                        has_intraday: true,
                        description: symbolName,
                        pricescale: 100,
                        volume_precision: 8,
                        exchange: "BINANCE"
                    });
                }, 0);
            },
            getBars: async (symbolInfo, resolution, from, to, onHistoryCallback, onError) => {
                try {
                    const startTime = from * 1000; // Convert from seconds to milliseconds
                    const endTime = to * 1000; // Convert from seconds to milliseconds
                    const url = `http://localhost:3000/proxy?url=https://api.binance.com/api/v3/klines?symbol=${activeSymbol}&interval=${resolution}&startTime=${startTime}&endTime=${endTime}`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        if (typeof onError === "function") {
                            onError("Network error: " + response.statusText);
                        }
                        return;
                    }

                    const data = await response.json();
                    if (Array.isArray(data)) {
                        const bars = data.map(item => ({
                            time: item[0] / 1000,
                            close: parseFloat(item[4]),
                            open: parseFloat(item[1]),
                            high: parseFloat(item[2]),
                            low: parseFloat(item[3]),
                            volume: parseFloat(item[5])
                        }));
                        onHistoryCallback(bars, { noData: bars.length === 0 });
                    } else if (typeof onError === "function") {
                        onError("Data format is incorrect");
                    }
                } catch (error) {
                    if (typeof onError === "function") {
                        onError(error.message);
                    }
                }
            },
            subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscribeUID, onReset) => {
                // Setup WebSocket to subscribe to all symbols
                const ws = new WebSocket(`wss://stream.binance.com:9443/ws/!ticker@arr`);
            
                ws.onopen = () => {
                    console.log("WebSocket connection opened successfully.");
                };
            
                ws.onmessage = (event) => {
                    try {
                        const trades = JSON.parse(event.data);
                        console.log("Received data array:", trades);  // Debug: log all received data
            
                        // Filter for the active symbol
                        const trade = trades.find(t => t.s === symbolInfo.name);
                        if (trade) {
                            console.log(`Processing trade for symbol: ${symbolInfo.name}`, trade);  // Log data specific to the active symbol
                            const bar = {
                                time: Date.now(),  // Adjusted to current time for real-time updates
                                close: parseFloat(trade.c),
                                open: parseFloat(trade.o),
                                high: parseFloat(trade.h),
                                low: parseFloat(trade.l),
                                volume: parseFloat(trade.v)
                            };
                            onRealtimeCallback(bar);
                        } else {
                            console.log(`No trade data found for symbol: ${symbolInfo.name}`);  // Log if no match for symbol
                        }
                    } catch (error) {
                        console.error("Error processing WebSocket message:", error);  // Log parsing errors
                    }
                };
            
                ws.onerror = (error) => console.error("WebSocket encountered an error:", error);  // Log WebSocket errors
            
                onReset = () => {
                    console.log("WebSocket connection closed.");
                    ws.close();
                };
            },
            
            
            unsubscribeBars: (subscribeUID) => {
                // Logic to unsubscribe can be added here if needed
            }
        };
    }

    document.addEventListener("DOMContentLoaded", function() {
        new TradingView.widget({
            container: "chart-container",
            autosize: true,
            symbol: "BINANCE:BTCUSDT", // Default symbol
            interval: "1", // Default interval (resolution)
            timezone: "exchange",
            theme: "dark",
            style: "1",
            library_path: "./charting_library/",
            locale: "en",
            enable_publishing: false,
            allow_symbol_change: true,
            datafeed: createDatafeed()
        });
    });
</script>

</body>
</html>
